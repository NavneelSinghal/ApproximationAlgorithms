\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
% \usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\usepackage{thmtools}
\usepackage{enumitem}
\usepackage[framemethod=TikZ]{mdframed}

\usepackage{xpatch}

\usepackage{boites}
\makeatletter
\xpatchcmd{\endmdframed}
{\aftergroup\endmdf@trivlist\color@endgroup}
{\endmdf@trivlist\color@endgroup\@doendpe}
{}{}
\makeatother

%\usepackage[poster]{tcolorbox}
%\allowdisplaybreaks
%\sloppy

\usepackage[many]{tcolorbox}

\xpatchcmd{\proof}{\itshape}{\bfseries\itshape}{}{}

% to set box separation
\setlength{\fboxsep}{0.8em}
\def\breakboxskip{7pt}
\def\breakboxparindent{0em}

\newenvironment{proof}{\begin{breakbox}\textit{Proof.}}{\hfill$\square$\end{breakbox}}
\newenvironment{ans}{\begin{breakbox}\textit{Answer.}}{\end{breakbox}}
\newenvironment{soln}{\begin{breakbox}\textit{Solution.}}{\end{breakbox}}

% \tcolorboxenvironment{proof}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     breakable,
%     left=12pt,
%     right=12pt,
%     top=12pt,
%     bottom=12pt,
% }
%
% \tcolorboxenvironment{ans}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     breakable,
%     left=12pt,
%     right=12pt,
% }

\mdfdefinestyle{enclosed}{
    linecolor=black
    ,backgroundcolor=none
    ,apptotikzsetting={\tikzset{mdfbackground/.append style={fill=gray!100,fill opacity=.3}}}
    ,frametitlefont=\sffamily\bfseries\color{black}
    ,splittopskip=.5cm
    ,frametitlebelowskip=.0cm
    ,topline=true
    ,bottomline=true
    ,rightline=true
    ,leftline=true
    ,leftmargin=0.01cm
    ,linewidth=0.02cm
    ,skipabove=0.01cm
    ,innerbottommargin=0.1cm
    ,skipbelow=0.1cm
}

\mdfsetup{%
    middlelinecolor=black,
    middlelinewidth=1pt,
roundcorner=4pt}

\setlength{\parindent}{0pt}

\mdtheorem[style=enclosed]{theorem}{Theorem}
%\mdtheorem[style=enclosed]{lemma}{Lemma}[theorem]
%\mdtheorem[style=enclosed]{claim}{Claim}[theorem]
\mdtheorem[style=enclosed]{lemma}{Lemma}[section]
\mdtheorem[style=enclosed]{claim}{Claim}[section]
\mdtheorem[style=enclosed]{ques}{Question}
\mdtheorem[style=enclosed]{defn}{Definition}
\mdtheorem[style=enclosed]{notn}{Notation}
\mdtheorem[style=enclosed]{obs}{Observation}
\mdtheorem[style=enclosed]{eg}{Example}
\mdtheorem[style=enclosed]{cor}{Corollary}
\mdtheorem[style=enclosed]{note}{Note}

% \let\thetheorem=\relax
% \let\thelemma=\relax
% \let\theclaim=\relax
% \let\theques=\relax
% \let\thedefn=\relax
% \let\thenotn=\relax
% \let\theobs=\relax
% \let\thecor=\relax
% \let\thenote=\relax

% \renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\nl}{\vspace{0.2cm}\\}
\newcommand{\ol}{\overline}
\newcommand{\eps}{\varepsilon}
\newcommand{\mc}{\mathcal}
\newcommand{\mi}{\mathit}
\newcommand{\mf}{\mathbf}
\newcommand{\mb}{\mathbb}
\newcommand{\R}{\mathbb{R}}
\newcommand{\OPT}{\mathbf{OPT}}
\newcommand{\ALG}{\mathbf{ALG}}
\renewcommand{\L}{\mc{L}}
\newcommand{\changesto}{\vdash}
\newcommand\Vtextvisiblespace[1][.3em]{%
    \mbox{\kern.06em\vrule height.3ex}%
    \vbox{\hrule width#1}%
    \hbox{\vrule height.3ex}
}
\newcommand{\blank}{{\Vtextvisiblespace[0.7em]}}
\newcommand{\leftend}{\triangleright}
\newcommand{\comp}{\overline}

\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\pdfsuppresswarningpagegroup=1

\title{\textbf{Assignment 1}}
\author{Navneel Singhal}
\date{2018CS10360}

\begin{document}
\maketitle
\tableofcontents

\section{Problem 1}
\subsection{Statement}
Give a greedy algorithm that achieves an approximation guarantee of $O(\log n)$ for set multicover, which is a generalization of set cover in which an integral coverage requirement is also specified
for each element and sets can be picked multiple number of times to satisfy all coverage requirements. Assume that the cost of picking $\alpha$ copies of set $S_i$ is $\alpha \cdot cost(S_i)$.
\subsection{Solution}
TODO

\newpage

\section{Problem 2}
\subsection{Statement}
Consider the following 2-approximation algorithm for the vertex cover problem. Find a depth first search tree in the given graph, $G$, and output the set, $S$, of non-leaf vertices of this tree. Show
that $S$ is indeed a vertex cover for $G$ and $|S| \le 2 \cdot \OPT$.
\subsection{Solution}
We shall use the abbreviation DFS-tree for depth-first-search tree in what follows.\nl
Since the DFS tree is a rooted tree, we will use the definition of a leaf as a vertex which doesn't have any children in the DFS tree (since otherwise, the claim in the problem statement doesn't
hold for graphs consisting of a single cycle, or a connected simple graph with 2 vertices).\nl
\begin{claim}
    $S$ is a vertex cover for $G$.
\end{claim}
\begin{proof}
    Suppose $S$ is not a vertex cover for $G$. Then there must exist an edge $(u, v)$ with none of $u, v$ in $S$, i.e., an edge between two leaves in the DFS-tree.\nl
    Note that the DFS-tree of any undirected graph partitions the set of edges of the graph into two sets - tree edges and back edges, where the tree edges correspond to the edges which appear in
    the DFS-tree, and the back edges (due to the properties of the DFS-tree) join a vertex to an ancestor of its own.\nl
    $(u, v)$ can't be a tree edge, since for that to happen, either of $u, v$ has to be the parent of the other in the DFS-tree, and since $u, v$ are distinct leaves, this is a contradiction. It can't be a back edge
    either, since otherwise either of $u, v$ has to be an ancestor of the other in the DFS-tree, which leads to a similar contradiction.\nl
    Hence we have shown that such a case can never arise, which shows that $S$ is a vertex cover for $G$.
\end{proof}
\begin{claim}
    The minimum vertex cover of a graph is at least as large as the minimum vertex cover of its DFS-tree.
\end{claim}
\begin{proof}
    For this, we note that the minimum vertex cover of a graph is also a vertex cover of its DFS-tree, since the set of edges of the DFS-tree is a subset of the set of edges of the graph itself, and
    hence any edge of the DFS-tree has an endpoint in the vertex cover of the original graph.\nl
    Hence the minimum vertex cover of a graph, being a vertex cover of the DFS-tree, is at least as large as the vertex cover of its DFS tree.
\end{proof}

Now if we show that the number of non-leaf vertices of a tree is at most twice the size of a vertex cover of a tree, we shall be done, since the size of $S$ will then be at most twice the size of a
vertex cover of the DFS tree, and hence at most twice the size of a vertex cover for the graph, which would complete the proof. Hence, it suffices to show the following claim:\nl

\begin{claim}
    For any tree, the size of the minimum vertex cover $VC(T)$ is at most twice the number of non-leaf vertices in the tree.
\end{claim}
\begin{proof}
    For this, we shall need the following two claims.\nl
    \begin{claim}
        For a tree, there is always a minimum vertex cover which doesn't contain any leaf, but contains all vertices adjacent to at least one leaf.
    \end{claim}
    \begin{proof}
        Note that there is no edge between two leaves by the definition of leaves in a rooted tree.\nl
        Consider the set of edges that are incident on a leaf.
        Note that the number of vertices adjacent to a leaf is at most the number of leaves, since the degree of a leaf is at most $1$ (to see why, note that the partial function from the set of
        leaves to the set of vertices adjacent to a leaf induced by the adjacency relation is surjective).\nl
        Now we do the following: replace each leaf in the minimum vertex cover with the vertex it is joined to by an edge. The resulting set is at most the size of the original vertex cover,
        and it is still a vertex cover, since the edges not incident to a leaf are still covered, while the edges incident to a leaf are now covered by a possibly different vertex.\nl
        Note that since this set is a vertex cover, it must consist of all vertices adjacent to a leaf, since otherwise the corresponding edge won't be covered by any vertex.\nl
        All in all, we have shown that we can modify a minimum vertex cover to another vertex cover which has no more vertices (hence it is also a minimum vertex cover) such that no leaf is in the
        vertex cover but all vertices adjacent to a leaf are, which proves this claim.
    \end{proof}
    \begin{claim}
        Let $L(T)$ be the set of leaves of a non-empty tree $T$, and let $P(T)$ be the set of vertices adjacent to a leaf. Then $P(T) \cup VC(T \setminus (P(T) \cup
        L(T))$ is a minimum vertex cover of $T$ (here $VC(\cdot)$ gives an arbitrary minimum vertex cover of a possibly empty tree (rooted or unrooted)).
    \end{claim}
    \begin{proof}
        From the previous claim, we know that there exists a vertex cover $VC(T)$ such that $P(T) \subseteq VC(T)$.\nl
        Note that removing $L(T)$ from $T$ makes $P(T)$ the set of leaves of the resulting tree, so $T \setminus (L(T) \cup P(T))$ is still a tree.\nl
        Firstly we show that $VC(T) \setminus P(T)$ is a vertex cover of $T \setminus (P(T) \cup L(T))$. Consider any edge $(u, v)$ in the tree formed by removing $P(T)$ and $L(T)$. It can't be
        incident to any vertex in $P(T)$ or $L(T)$ since we have removed these vertices. Since $VC(T)$ is a vertex cover, at least one of $u, v$ must be in $VC(T)$. Since none of $u, v$ is
        in $P(T)$, at least one of $u, v$ must be in $VC(T) \setminus P(T)$. Since our edge was arbitrarily chosen, we are done with this part.\nl
        Now we show that $P(T) \cup VC(T \setminus (P(T) \cup L(T)))$ is a vertex cover of $T$. Consider any edge of $T$. If the edge is incident to a leaf of $T$, it is covered by $P(T)$. If
        the edge is incident to any vertex of $P(T)$, it is covered by that vertex in $P(T)$. If none of these is true, then both endpoints must be in $T \setminus (P(T) \cup L(T))$, and hence
        it is covered by a vertex in $VC(T \setminus (P(T) \cup L(T)))$. So the exhibited set is indeed a vertex cover.\nl
        Now we show that this is a minimum vertex cover. Suppose this is not a minimum set cover. By the previous claim, there exists a minimum vertex cover of $T$ which contains $P(T)$. Then
        since we have shown that if we remove $P(T)$ from any minimum vertex cover of $T$, we get a vertex cover for $T \setminus (P(T) \cup L(T))$. Doing this to a minimum set cover of $T$ which
        has $P(T)$ as a subset gives us a smaller vertex cover of $T \setminus (P(T) \cup L(T))$ than $VC(T \setminus (P(T) \cup L(T)))$, which is a contradiction. This completes the proof.
    \end{proof}
    %Now with these claims, we are ready to prove this theorem by induction.\nl
    %The base case is $n \le 2$, and there is nothing to prove in those cases.\nl
    %Now suppose $n \ge 3$. Consider $T \setminus (P(T) \cup V(T))$, and the minimum vertex cover $$
    From the claims above, we can note that the following algorithm gives us
    a minimum vertex cover of a rooted tree:
    \begin{algorithmic}[1]
        \Function{MinVertexCover}{Rooted Tree $T$}
            \State \textbf{let} $A \gets \{\}$
            \State \textbf{let} $i \gets 1$
            \While{$T$ has at least $1$ vertex}
                \State \textbf{let} $L_i \gets$ the set of leaves of $C$
                \State \textbf{let} $P_i \gets$ the set of vertices adjacent to a leaf of $C$.
                \State $A \gets A \cup P_i$
                \State $T \gets T \setminus (L_i \cup P_i)$
                \State $i \gets i + 1$
            \EndWhile
            \State \Return $A$
        \EndFunction
    \end{algorithmic}
    Consider the sets $L_i$ and $P_i$. We can partition the set of vertices of $T$ as $\cup_{i=1}^m (L_i \cup P_i)$ where $m$ is the number of steps taken by the while loop.
    The corresponding minimum set cover is $\cup_{i=1}^m P_i$.
    The non-leaf vertices of this tree are $S = \cup_{i=1}^m (P_i \cup L_{i+1})$, where $L_{m+1} = \emptyset$ for the sake of convenience. Note that all unions here are disjoint unions.\nl
    As observed before, we have that $P_i$ is the set of leaves of the tree formed when we remove $L_i$ from $T$ at the $i^\mathrm{th}$ step, and $L_{i+1}$ is the set of leaves of the tree
    formed when we remove $P_i$ from this tree. So by an argument similar to the one in the proof of Claim 2.4, we
    have that $|P_i| \ge |L_{i+1}|$. Hence we have
    \begin{align*}
        \OPT &= |\cup_{i=1}^m P_i|\\
             &= \sum_{i=1}^m |P_i|\\
             &\ge \sum_{i=1}^m \frac{|P_i| + |L_{i+1}|}{2}\\
             &= \frac{1}{2} \sum_{i=1}^m |P_i| + |L_{i+1}|\\
             &= \frac{1}{2} |\cup_{i=1}^m (P_i \cup L_{i+1})|\\
             &= \frac{|S|}{2}
    \end{align*}
    Rearranging this gives $|S| \le 2 \cdot \OPT$, as needed.
\end{proof}

\newpage

\section{Problem 3}
\subsection{Statement}
In the \emph{maximum coverage problem}, we have a set of elements $E$, and $m$ subsets of elements $S_1, \ldots, S_m \subseteq E$. The goal is to choose $k$ sets such that we maximize the number of
elements that are covered; an element $s$ is covered if it belongs to one of the sets picked. Give a $\left(1-\frac{1}{e}\right)$-approximation algorithm for this problem.
\subsection{Solution}
TODO

\newpage

\section{Problem 4}
\subsection{Statement}
In the \emph{related machines scheduling problem}, we are given $m$ machines and $n$ jobs. Job $j$ has processing time $p_j$ and machine $i$ has speed $s_i$.  Machine $i$ takes $p_j/s_i$ time to
complete job $j$. Given $T$ design a polynomial time algorithm which either schedules jobs on the $m$ machines such that they finish by time $2T$ or proves that there is no way of scheduling jobs so
that they all finish by time $T$.
\subsection{Solution}
TODO

\end{document}
