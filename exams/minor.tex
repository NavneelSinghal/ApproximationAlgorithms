\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
% \usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\usepackage{thmtools}
\usepackage{enumitem}
\usepackage[framemethod=TikZ]{mdframed}

\usepackage{xpatch}

\usepackage{boites}
\makeatletter
\xpatchcmd{\endmdframed}
{\aftergroup\endmdf@trivlist\color@endgroup}
{\endmdf@trivlist\color@endgroup\@doendpe}
{}{}
\makeatother

%\usepackage[poster]{tcolorbox}
%\allowdisplaybreaks
%\sloppy

\usepackage[many]{tcolorbox}

\xpatchcmd{\proof}{\itshape}{\bfseries\itshape}{}{}

% to set box separation
\setlength{\fboxsep}{0.8em}
\def\breakboxskip{7pt}
\def\breakboxparindent{0em}

\newenvironment{proof}{\begin{breakbox}\textit{Proof.}}{\hfill$\square$\end{breakbox}}
\newenvironment{ans}{\begin{breakbox}\textit{Answer.}}{\end{breakbox}}
\newenvironment{soln}{\begin{breakbox}\textit{Solution.}}{\end{breakbox}}

% \tcolorboxenvironment{proof}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     breakable,
%     left=12pt,
%     right=12pt,
%     top=12pt,
%     bottom=12pt,
% }
%
% \tcolorboxenvironment{ans}{
%     blanker,
%     before skip=\topsep,
%     after skip=\topsep,
%     borderline={0.4pt}{0.4pt}{black},
%     breakable,
%     left=12pt,
%     right=12pt,
% }

\mdfdefinestyle{enclosed}{
    linecolor=black
    ,backgroundcolor=none
    ,apptotikzsetting={\tikzset{mdfbackground/.append style={fill=gray!100,fill opacity=.3}}}
    ,frametitlefont=\sffamily\bfseries\color{black}
    ,splittopskip=.5cm
    ,frametitlebelowskip=.0cm
    ,topline=true
    ,bottomline=true
    ,rightline=true
    ,leftline=true
    ,leftmargin=0.01cm
    ,linewidth=0.02cm
    ,skipabove=0.01cm
    ,innerbottommargin=0.1cm
    ,skipbelow=0.1cm
}

\mdfsetup{%
    middlelinecolor=black,
    middlelinewidth=1pt,
roundcorner=4pt}

\setlength{\parindent}{0pt}

\mdtheorem[style=enclosed]{theorem}{Theorem}
%\mdtheorem[style=enclosed]{lemma}{Lemma}[theorem]
%\mdtheorem[style=enclosed]{claim}{Claim}[theorem]
\mdtheorem[style=enclosed]{lemma}{Lemma}[section]
\mdtheorem[style=enclosed]{claim}{Claim}[section]
\mdtheorem[style=enclosed]{ques}{Question}
\mdtheorem[style=enclosed]{defn}{Definition}
\mdtheorem[style=enclosed]{notn}{Notation}
\mdtheorem[style=enclosed]{obs}{Observation}
\mdtheorem[style=enclosed]{eg}{Example}
\mdtheorem[style=enclosed]{cor}{Corollary}
\mdtheorem[style=enclosed]{note}{Note}

% \let\thetheorem=\relax
% \let\thelemma=\relax
% \let\theclaim=\relax
% \let\theques=\relax
% \let\thedefn=\relax
% \let\thenotn=\relax
% \let\theobs=\relax
% \let\thecor=\relax
% \let\thenote=\relax

% \renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\nl}{\vspace{0.2cm}\\}
\newcommand{\ol}{\overline}
\newcommand{\eps}{\varepsilon}
\newcommand{\mc}{\mathcal}
\newcommand{\mi}{\mathit}
\newcommand{\mf}{\mathbf}
\newcommand{\mb}{\mathbb}
\newcommand{\R}{\mathbb{R}}
\newcommand{\OPT}{\mathbf{OPT}}
\newcommand{\ALG}{\mathbf{ALG}}
\newcommand{\th}{{th}}
\renewcommand{\L}{\mc{L}}
\newcommand{\changesto}{\vdash}
\newcommand\Vtextvisiblespace[1][.3em]{%
    \mbox{\kern.06em\vrule height.3ex}%
    \vbox{\hrule width#1}%
    \hbox{\vrule height.3ex}
}
\newcommand{\blank}{{\Vtextvisiblespace[0.7em]}}
\newcommand{\leftend}{\triangleright}
\newcommand{\comp}{\overline}

\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\pdfsuppresswarningpagegroup=1

\title{\textbf{Midterm}}
\author{Navneel Singhal}
\date{2018CS10360}

\begin{document}
\maketitle
\tableofcontents

% \begin{algorithmic}[1]
%     \Function{ApproxSetMulticover}{$U = \{e_1, \ldots, e_n\}$, $\mathcal{S} = \{S_1, \ldots, S_m\}$, $req[1\ldots n]$}
%         \State Let $X \gets U$ \Comment The set of elements whose requirements haven't been met so far
%         \State Let $A$ be a multiset of subsets of $U$, initialized to $\emptyset$.
%         \State Let $f[1\ldots n]$ be an array initialized to all 0s
%         \Comment $f[i]$ will be the number of copies of $e_i$ covered so far
%         \While{$X$ is non-empty}
%             \State Let $S_i$ be a set that covers the most number of elements in $X$
%             \State Insert $S_i$ into $A$
%             \For{$e_j$ in $S_i$}
%                 \State $f[j] \gets f[j] + 1$
%                 \If{$f[j] = req[j]$}
%                     \State Remove $e_j$ from $X$.
%                 \EndIf
%             \EndFor
%         \EndWhile
%         \State \Return $A$
%     \EndFunction
% \end{algorithmic}

\newpage

\section{Problem 1}

\subsection{Statement}
\subsection{Solution}

\newpage

\section{Problem 2}

\subsection{Statement}

Let $x^*$ be an optimum solution to the linear relaxation of the integer program for minimum vertex cover in $G = (V, E)$. Suppose $x_i^* \in \{0,1/2,1\},1 \le i \le n$ where $x_i$ is the variable
associated with $v_i \in V$. Further assume that the vertices of $G$ are colored with $4$ colors such that every pair of adjacent vertices have different colors. How will you round the solution
$x^*$ to obtain a $1.5$-approximation for the minimum vertex cover. Give an algorithm and analyse its guarantee.

\subsection{Solution}

Since the statement mentions that we are already given such a colouring, we will assume that the input additionally contains the colouring information for all vertices in the graph.\nl
Without loss of generality, let the colours be red, blue, green, yellow. Our algorithm will be as follows:

\begin{enumerate}
    \item Find a colour $c$ with the most number of vertices coloured with that colour which have $x_i^* = \frac{1}{2}$ (i.e., $c$ is a majority colour among vertices $v_i$ which have $x_i^* =
        \frac{1}{2}$).
    \item Initialize set $S$ with the empty set.
    \item For each vertex $v_i$ in $V$, add $v_i$ to $S$ if and only either
        \begin{itemize}
            \item $x_i^* = 1$, or
            \item $x_i^* = \frac{1}{2}$ and the colour of $v_i$ is not $c$
        \end{itemize}
        (i.e., round an $x_i^*$ with value $\frac{1}{2}$ to $1$ if and only if the colour of $v_i$ is not $c$, else round it down to $0$).
    \item Return $S$.
\end{enumerate}

For the sake of convenience, we suppose that the colour $c$ that was picked is blue.\nl

\begin{claim}
    $S$ is a vertex-cover.
\end{claim}

\begin{proof}
    Suppose there is an edge which has not been covered. Then there exists an edge $(v_i, v_j)$ such that after rounding the solution from $x^*$ to $\overline{x}$, we have $\overline{x}_i +
    \overline{x}_j
    < 1$. Since both of these are integers, this can happen iff both $\overline{x}_i, \overline{x}_j$ are 0. In the case that either of $x^*_i$ and $x^*_j$ is $0$, the other variable must have been
    1, which couldn't have been rounded down. And if either of them is $1$, it isn't rounded down anyway, so the inequality is still satisfied.\nl
    Hence, the only possibility is that both of $x^*_i, x^*_j$ are $\frac{1}{2}$, and both of $\overline{x}_i, \overline{x}_j$ are both rounded down to $0$. This is only possible if both $v_i,
    v_j$
    were blue, which is impossible since the condition on the colouring guarantees that $v_i, v_j$ must have had opposite colours.\nl
    This is a contradiction, and hence, $S$ is a valid vertex cover.
\end{proof}

\begin{claim}
    $|S| \le \frac{3}{2} \cdot \OPT$
\end{claim}

\begin{proof}
    Let the set of vertices with $x_i^* = 1$ be $A$, the set with $x_i^* = 0$ be $B$, and the set with $x_i^* = \frac{1}{2}$ be $C$. Let $D$ be the subset of $C$ which consists of vertices
    which have colour blue.\nl
    Note that $\OPT \ge \OPT_{LP} = |A| + \frac{1}{2} |C|$, since the LP is a relaxed version of the original problem.\nl
    Now note that since blue is a majority colour among vertices in $C$, it must have at least $\frac{1}{4} |C|$ vertices.\nl
    Now consider the following inequalities:\nl
    \begin{align*}
        \ALG &= |A| + |C| - |D|\\
             &\le |A| + \frac{3}{4} \cdot |C|\\
             &\le \frac{3}{2} \cdot |A| + \frac{3}{4} \cdot |C|\\
             &= \frac{3}{2} \cdot \left(|A| + \frac{1}{2} \cdot |C|\right)\\
             &= \frac{3}{2} \cdot \OPT_{LP}\\
             &\le \frac{3}{2} \cdot \OPT
    \end{align*}
    This completes the proof.
\end{proof}

\newpage

\section{Problem 3}

\subsection{Statement}

We are given a directed acyclic graph $G = (V, E)$, vertices $s, t \in V$, edge-costs $c : E \to \R^+$, edge-lengths $l : E \to \R^+$, and a length bound $L$. Give a full polynomial time approximation
scheme (FPTAS) to find the minimum cost path from $s$ to $t$ of length at most $L$.  Hint: First give a dynamic program to solve the problem assuming the edge-costs are integers.

\subsection{Solution}

Firstly, we give a dynamic program that works if all the edge weights $c_i$ are integer weights.

\begin{algorithmic}[1]
    \Function{MinCostPath}{$G = (V, E)$, $s$, $t$, $n = |V|$, $m = |E|$, $c[1\ldots m]$, $l[1 \ldots m]$, $L$}
        \State Let $ord$ be a topologically sorted order of vertices in $G$
        \State \Comment i.e., $ord[i]$ denotes the $i^{th}$ vertex in this topologically sorted order. We can maintain a permutation that gives us, given a vertex $v$, the index $i$ such that
        $ord[i] = v$, and this can be constructed in linear time.
        \State Let $C \gets \max_i c[i]$
        \State Let $minLen[1 \ldots n][0 \ldots Cn]$ be a matrix initialized to $\infty$
        \State \Comment For our purposes, initializing it to $L + 1$ works as well.
        \State \Comment $minLen[i][j]$ will represent the minimum length of a path from $ord[i]$ to $k$ with cost at most $j$
        \State Let $q$ be the index such that $ord[p] = t$.
        \State Let $p$ be the index such that $ord[q] = s$.
        \If{$p > q$}
            \State \Return failure
        \EndIf
        \For{$i$ from $0$ to $Cn$}
            \State $minLen[q][i] \gets 0$
        \EndFor
        \For{$i$ from $q - 1$ down to $p$}
            \For{$j$ from $0$ to $Cn$}
                \If{$j \ne 0$}
                    \State $minLen[i][j] \gets minLen[i][j - 1]$
                \EndIf
                \For{each edge $(ord[i], ord[k])$ (with id $r$) with cost $c[r] \le j$}
                    \State $minLen[i][j] \gets \min(minLen[i][j], minLen[k][j - c[r]] + l[r])$
                \EndFor
            \EndFor
        \EndFor
        \If{$minLen[p][Cn] > L$}
            \State \Return failure
        \EndIf
        \State Let $c'$ be the minimum index with $minLen[p][c'] \le L$.
        \State Let $l'$ be $minLen[p][c']$
        \State Let $path \gets$ list consisting only of $p$
        \While{$p \ne q$}
            \State Let $(p, r)$ be an edge with cost $f$ and length $g$, and $minLen[r][c' - f] = l' - g$.
            \State $c' \gets c' - f$
            \State $l' \gets l' - g$
            \State $p \gets r$
            \State Append $p$ to $path$
        \EndWhile
        \State \Return $path$
    \EndFunction
\end{algorithmic}

\begin{claim}
    This algorithm returns failure if there is no path with length $\le L$, else it returns a minimum cost with length at most $L$.
\end{claim}
\begin{proof}
    Note that since $ord$ is a topological ordering of the vertices, any edge joins a vertex $v_i$ to $v_j$ only if $i < j$.\nl
    Firstly, we claim that $minLen[i][j]$ does indeed satisfy the property in line $7$, after the nested iteration for $j$ in the corresponding iteration for $i$ is completed.\nl
    For the case $i = q$, it is fairly straightforward, since the empty path has length $L$ and all paths have non-negative lengths so we can't do better.\nl
    Now suppose this is true for all $i' > i$. We show that this is true for $i$ as well. Now consider any path with cost $x$ and length $y$, starting at $ord[i]$. Then there must be an edge from
    $ord[i]$ to some $ord[k]$ with index $r$ and cost $c[r]$ and length $l[r]$ such that the cost of the path from $ord[k]$ to $t$ is $x - c[r]$ and the length is $y - l[r]$.\nl
    Fix some $j$. Then this holds for each path with cost $\le j$ as well. Moreover, we must have the cost of the remaining path be non-negative (since edge costs are non-negative integers).
    So, it is sufficient to fix an edge and consider the minimum length of a path from $ord[k]$ to $t$ with cost at most $j - c[r]$ (since path lengths are additive), and then take the minimum
    over all edges coming out of $ord[i]$, which completes the proof of the claim.\nl
    Now suppose there is no path with length $\le L$ between $s$ and $t$. Then we have $minLen[p][c] > L$ for all $c \in [0\ldots Cn]$, so we return failure in this case.\nl
    Now suppose there is indeed such a path. Then the number of edges in the path are at most $n - 1$, so the path cost is bounded above by $C(n - 1) < Cn$. Hence, by the claim, we have that
    the minimum $c$ for which $minlen[p][c]$ is $\le L$ is indeed the minimum cost which is required (and such a $c$ exists since we have assumed that such a path exists, so
    $minLen[p][cost(path)] \le L$ by the claim). The rest of the algorithm is just construction of the path from the $minLen$ values, which is a straightforward simulation of walking on
    the path.
\end{proof}

Note that this algorithm uses $Cn$ as an upper bound on the cost of $\OPT$, and there is implicitly a lower bound of $1$ since weights belong to $\R^+$, and the only case where the answer is $0$
is the case when $s = t$, which is trivial. We will try to iteratively find better and better lower bounds so that we can get a better algorithm.\nl

Firstly note that we can change the order of computation of our dynamic program from row major to column major order, by noting that $(i, j)$ is computed strictly after $(i - 1, *)$, and it
depends only on smaller $j$. By allocating memory only for the columns we need (this can be done by swapping rows and columns and the coordinates in our algorithm), we will get another algorithm
which would run in $O((n + m) \cdot \OPT)$. Call this the \textbf{good} algorithm.\nl

To reduce the upper bound, we will try to binary search on it (with the initial range being $[1, Cn]$, where $C$ is the max cost edge length).\nl

For the binary search, we will use the following approximate predicate for a given $0 < r < 1$, given an upper bound $B$ to test:

\begin{enumerate}
    \item Remove all edges with cost $> B$, and replace the cost of edge $e$ with $\lfloor cost \cdot n / (B r) \rfloor$
    \item For $c$ in $0$ to $\frac{n}{r}$:
        \begin{itemize}
            \item Compute the $minLen$ values for cost = $c$ (this corresponds to a column) using the good algorithm.
            \item If we have $minLen[p][c] \le L$, return false.
        \end{itemize}
    \item Return true
\end{enumerate}

\begin{claim}
    If this predicate returns false, then $\OPT \le (1 + r) B$, else $\OPT > B$.
\end{claim}
\begin{proof}
    Suppose we return false. Then we have a path in the rounded instance with cost $c$, and since the number of edges on the path can be at most $n$, and the maximum length we have shaved off an edge by
    rounding to be $Br/n$
    rounding to be , we have the path cost at most $B + n \cdot Br / n = B(1 + r)$.\nl
    If we return true, this means that even in the relaxed instance (after scaling and rounding), there is no solution with cost $\le \frac{n}{r}$, i.e., in the relaxed instance where we scale back after
    rounding, there is no solution with cost $\le \frac{n}{r} \cdot \frac{Br}{n} = B$, so even for the original problem, there is no solution with cost $B$, which completes the proof.
\end{proof}

Hence using this algorithm, we can choose $r = \frac{1}{\sqrt{2}}$, and run this algorithm while doing a binary search on $\log \OPT$, while the ratio between the lower bound and the upper bound is
not $2$. It will always lead to a reduction of the ratio between by at least a factor of $\sqrt{2}$ each time, i.e., a reduction of $\log$ of the upper bound by at least $\frac{1}{2}$ each time.
The time taken by the predicate to run is $O(n)$, so we will end up with an $O(n \log (Cn))$ algorithm till we get an upper bound which is at most two times the lower bound.\nl
Note that since $\log C$ is the size of $C$ in the input, this is polynomial time in input.\nl
Hence using this algorithm (which in turn depends on the good algorithm), we have finally found an upper bound which is at most twice $\OPT$ (since lower bound is $\le \OPT$), and that too in
polynomial time.

Now our FPTAS will be as follows:

\begin{enumerate}
    \item Let $C$ be an upper bound on the answer found from the algorithm (this is different from the definition of $C$ used above).
    \item Multiply all edge costs with $\frac{2n}{\eps C}$, and round them up.
    \item Run the algorithm on this modified instance (and in the algorithm, replace the $Cn$ in the algorithm by $\frac{2n}{\eps}$ that we have chosen, since this is now the upper bound on the
        optimal path cost), and return the output of this algorithm.
\end{enumerate}

\begin{claim}
    This is a $(1 + \eps)$ approximation.
\end{claim}
\begin{proof}
    Consider the optimal solution (under the condition that a solution exists). Note that our algorithm also returns a solution, since we haven't changed $L$ or the edge lengths, or the
    structure of the graph. Suppose the edge costs on the path were $x_1, \ldots, x_k$. Then in the modified instance, it corresponds to $\lceil\frac{2nx_1}{C\eps}\rceil,\ldots
    \lceil\frac{2nx_k}{C\eps}\rceil$. Suppose the edge costs on the path returned by our algorithm are $y_1, \ldots, y_K$. Then in the modified instance, the edge costs are $\lceil\frac{2ny_1}{C\eps}\rceil,\ldots
    \lceil\frac{2ny_K}{C\eps}\rceil$.\nl
    We then have the following:
    \begin{align*}
        \sum_{i = 1}^K y_i &\le \frac{C\eps}{2n} \cdot \sum_{i = 1}^K \left\lceil \frac{2n y_i}{C\eps} \right\rceil\\
                &= \OPT_{modified}\\
                &\le \frac{C\eps}{2n} \cdot \sum_{i = 1}^k \left\lceil \frac{2n x_i}{C\eps} \right\rceil\\
                &\le \frac{C\eps}{2n} \cdot \sum_{i = 1}^k \left(1 + \frac{2n x_i}{C \eps}\right)\\
                &= \OPT + \frac{kC\eps}{2n}\\
                &\le \OPT + \frac{k \cdot \OPT}{n}\\
                &\le \OPT \cdot (1 + \eps)
    \end{align*}
\end{proof}

\begin{claim}
    The running time of this algorithm is $O(n(n + m) / \eps)$
\end{claim}
\begin{proof}
    Note that the time taken by the algorithm is $O((n + m) \cdot (\text{upper bound on OPT for the instance passed to the algorithm}))$, which is $O((n + m) \cdot \frac{2n}{\eps})$, and
    we are done.
\end{proof}

This shows that we indeed have a FPTAS for this final algorithm.

\newpage

\section{Problem 4}

\subsection{Statement}
\subsection{Solution}

\newpage

\section{Problem 5}

\subsection{Statement}
\subsection{Solution}

\end{document}
